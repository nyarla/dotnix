Based on: https://github.com/Titaniumtown/nsfminer/commit/ed645078cdf28c0d8403c2820eec2a4f978ed5fe.patch
License: GPL v3
---
diff --git a/libcl/CLMiner.cpp b/libcl/CLMiner.cpp
index 721e8ea16..e36605993 100644
--- a/libcl/CLMiner.cpp
+++ b/libcl/CLMiner.cpp
@@ -594,6 +594,8 @@ bool CLMiner::initEpoch() {
         m_abortqueue = new cl::CommandQueue(*m_context, m_device);
 
         m_dagItems = m_epochContext.dagNumItems;
+        m_dagInv = m_epochContext.dagInv;
+        m_dagShift = m_epochContext.dagShift;
 
         bool dagOk = true;
         // create buffer for dag
@@ -677,6 +679,8 @@ bool CLMiner::initEpoch() {
         m_searchKernel.setArg(2, *m_dag[0]);
         m_searchKernel.setArg(3, *m_dag[1]);
         m_searchKernel.setArg(4, m_dagItems);
+        m_searchKernel.setArg(7, m_dagInv);
+        m_searchKernel.setArg(8, m_dagShift);
 
         m_queue->enqueueWriteBuffer(*m_searchBuffer, CL_FALSE, 0, sizeof(zerox3), zerox3);
 
diff --git a/libcl/CLMiner.h b/libcl/CLMiner.h
index f1071ba38..d3e76e2a7 100644
--- a/libcl/CLMiner.h
+++ b/libcl/CLMiner.h
@@ -111,6 +111,8 @@ class CLMiner : public Miner {
     }
 
     unsigned m_dagItems = 0;
+    uint32_t m_dagInv = 0;
+    uint32_t m_dagShift = 0;
     std::mutex m_abortMutex;
 };
 
diff --git a/libcl/ethash.cl b/libcl/ethash.cl
index a550e2d00..613e23ea4 100644
--- a/libcl/ethash.cl
+++ b/libcl/ethash.cl
@@ -241,11 +241,18 @@ typedef union
     uint uints[16];
 } compute_hash_share;
 
+// computes a mod dag_size
+static uint mod(uint a, uint dag_size, uint dag_inv, uint dag_shift) {
+    uint d = mul_hi(a, dag_inv) >> dag_shift;
+    uint r = a - d * dag_size;
+    return r;
+}
+
 #ifdef SPLIT_DAG
 #define MIX(x)                                                                       \
     do                                                                               \
     {                                                                                \
-        buffer[get_local_id(0)] = fnv(init0 ^ (a + x), ((uint*)&mix)[x]) % dag_size; \
+        buffer[get_local_id(0)] = mod(fnv(init0 ^ (a + x), ((uint*)&mix)[x]), dag_size, dag_inv, dag_shift); \
         uint idx = buffer[lane_idx];                                                 \
         __global hash128_t const* g_dag =                                            \
             (__global hash128_t const*)_g_dag2[idx & 1];                             \
@@ -256,7 +263,7 @@ typedef union
 #define MIX(x)                                                                       \
     do                                                                               \
     {                                                                                \
-        buffer[get_local_id(0)] = fnv(init0 ^ (a + x), ((uint*)&mix)[x]) % dag_size; \
+        buffer[get_local_id(0)] = mod(fnv(init0 ^ (a + x), ((uint*)&mix)[x]), dag_size, dag_inv, dag_shift); \
         uint idx = buffer[lane_idx];                                                 \
         __global hash128_t const* g_dag = (__global hash128_t const*)_g_dag0;        \
         mix = fnv(mix, g_dag[idx].uint8s[thread_id]);                                \
@@ -274,9 +281,15 @@ struct SearchResults
 };
 
 __attribute__((reqd_work_group_size(WORKSIZE, 1, 1))) __kernel void search(
-    __global struct SearchResults* g_output, __constant uint2 const* g_header,
-    __global ulong8 const* _g_dag0, __global ulong8 const* _g_dag1, uint dag_size,
-    ulong start_nonce, ulong target)
+    __global struct SearchResults* g_output,    //0
+    __constant uint2 const* g_header,           //1
+    __global ulong8 const* _g_dag0,             //2
+    __global ulong8 const* _g_dag1,             //3
+    uint dag_size,                              //4
+    ulong start_nonce,                          //5
+    ulong target,                               //6
+    uint dag_inv,                               //7
+    uint dag_shift)                             //8
 {
     if (g_output->abort)
         return;
diff --git a/libcuda/CUDAMiner.cpp b/libcuda/CUDAMiner.cpp
index 9f781d96e..b386abd4c 100644
--- a/libcuda/CUDAMiner.cpp
+++ b/libcuda/CUDAMiner.cpp
@@ -111,8 +111,8 @@ bool CUDAMiner::initEpoch() {
 
         HostToDevice(light, m_epochContext.lightCache, m_epochContext.lightSize);
 
-        set_constants(dag, m_epochContext.dagNumItems, light,
-                      m_epochContext.lightNumItems); // in ethash_cuda_miner_kernel.cu
+        set_constants(dag, m_epochContext.dagNumItems, light, m_epochContext.lightNumItems,
+            m_epochContext.dagInv, m_epochContext.dagShift); // in ethash_cuda_miner_kernel.cu
 
         ethash_generate_dag(m_epochContext.dagSize, m_block_multiple, m_deviceDescriptor.cuBlockSize, m_streams[0]);
 
@@ -175,9 +175,17 @@ void CUDAMiner::workLoop() {
 
             // adjust work multiplier
             float hr = RetrieveHashRate();
-            if (hr >= 1e7)
+            if (hr >= 1e7) {
                 m_block_multiple = uint32_t((hr * CU_TARGET_BATCH_TIME) /
                                             (m_deviceDescriptor.cuStreamSize * m_deviceDescriptor.cuBlockSize));
+                m_block_multiple--;
+                m_block_multiple |= m_block_multiple >> 1; 
+                m_block_multiple |= m_block_multiple >> 2; 
+                m_block_multiple |= m_block_multiple >> 4;
+                m_block_multiple |= m_block_multiple >> 8;
+                m_block_multiple |= m_block_multiple >> 16;
+                m_block_multiple++;                
+            }
 
             // Eventually start searching
             search(current.header.data(), upper64OfBoundary, current.startNonce, current);
diff --git a/libcuda/CUDAMiner.h b/libcuda/CUDAMiner.h
index 612583e48..0ddb3e1de 100644
--- a/libcuda/CUDAMiner.h
+++ b/libcuda/CUDAMiner.h
@@ -18,7 +18,7 @@
 #include <functional>
 
 #define MAX_STREAMS 4
-#define CU_TARGET_BATCH_TIME 0.9F // seconds
+#define CU_TARGET_BATCH_TIME 0.5F // seconds
 
 namespace dev {
 namespace eth {
diff --git a/libcuda/dagger_shuffled.cuh b/libcuda/dagger_shuffled.cuh
index 0111f9fdb..018c47203 100644
--- a/libcuda/dagger_shuffled.cuh
+++ b/libcuda/dagger_shuffled.cuh
@@ -15,6 +15,13 @@
 
 #define _PARALLEL_HASH 4
 
+// computes a mod dag_size
+DEV_INLINE uint32_t mod(uint32_t a) {
+    uint32_t d = __umulhi(a, d_dag_inv) >> d_dag_shift;
+    uint32_t r = a - d * d_dag_size; 
+    return r;
+}
+
 DEV_INLINE bool compute_hash(uint64_t nonce) {
     // sha3_512(header .. nonce)
     uint2 state[12];
@@ -61,8 +68,8 @@ DEV_INLINE bool compute_hash(uint64_t nonce) {
 
             for (uint32_t b = 0; b < 4; b++) {
                 for (int p = 0; p < _PARALLEL_HASH; p++) {
-                    offset[p] = fnv(init0[p] ^ (a + b), ((uint32_t*)&mix[p])[b]) % d_dag_size;
-                    offset[p] = SHFL(offset[p], t, THREADS_PER_HASH);
+                    const uint32_t temp = mod( fnv(init0[p] ^ (a + b), ((uint32_t*)&mix[p])[b]) );
+                    offset[p] = SHFL(temp, t, THREADS_PER_HASH);
                     mix[p] = fnv4(mix[p], d_dag[offset[p]].uint4s[thread_id]);
                 }
             }
diff --git a/libcuda/ethash_cuda_miner_kernel.cu b/libcuda/ethash_cuda_miner_kernel.cu
index 83dc09fac..786ab8838 100644
--- a/libcuda/ethash_cuda_miner_kernel.cu
+++ b/libcuda/ethash_cuda_miner_kernel.cu
@@ -100,14 +100,16 @@ void ethash_generate_dag(uint64_t dag_size, uint32_t gridSize, uint32_t blockSiz
     CUDA_CALL(cudaGetLastError());
 }
 
-void set_constants(hash128_t* _dag, uint32_t _dag_size, hash64_t* _light, uint32_t _light_size) {
+void set_constants(hash128_t* _dag, uint32_t _dag_size, hash64_t* _light, uint32_t _light_size, uint32_t dag_inv, uint32_t dag_shift) {
     CUDA_CALL(cudaMemcpyToSymbol(d_dag, &_dag, sizeof(hash128_t*)));
     CUDA_CALL(cudaMemcpyToSymbol(d_dag_size, &_dag_size, sizeof(uint32_t)));
     CUDA_CALL(cudaMemcpyToSymbol(d_light, &_light, sizeof(hash64_t*)));
     CUDA_CALL(cudaMemcpyToSymbol(d_light_size, &_light_size, sizeof(uint32_t)));
+    CUDA_CALL(cudaMemcpyToSymbol(d_dag_inv, &dag_inv, sizeof(uint32_t)));
+    CUDA_CALL(cudaMemcpyToSymbol(d_dag_shift, &dag_shift, sizeof(uint32_t)));
 }
 
-void get_constants(hash128_t** _dag, uint32_t* _dag_size, hash64_t** _light, uint32_t* _light_size) {
+void get_constants(hash128_t** _dag, uint32_t* _dag_size, hash64_t** _light, uint32_t* _light_size, uint32_t* dag_inv, uint32_t* dag_shift) {
     /*
        Using the direct address of the targets did not work.
        So I've to read first into local variables when using cudaMemcpyFromSymbol()
@@ -132,6 +134,18 @@ void get_constants(hash128_t** _dag, uint32_t* _dag_size, hash64_t** _light, uin
         CUDA_CALL(cudaMemcpyFromSymbol(&_ls, d_light_size, sizeof(uint32_t)));
         *_light_size = _ls;
     }
+
+    if (dag_inv) {
+        uint32_t _dag_inv;
+        CUDA_CALL(cudaMemcpyFromSymbol(&_dag_inv, d_dag_inv, sizeof(uint32_t)));
+        *dag_inv = _dag_inv;
+    }
+
+    if (dag_shift) {
+        uint32_t _dag_shift;
+        CUDA_CALL(cudaMemcpyFromSymbol(&_dag_shift, d_dag_shift, sizeof(uint32_t)));
+        *dag_shift = _dag_shift;
+    }
 }
 
 void set_header(hash32_t _header) { CUDA_CALL(cudaMemcpyToSymbol(d_header, &_header, sizeof(hash32_t))); }
diff --git a/libcuda/ethash_cuda_miner_kernel.h b/libcuda/ethash_cuda_miner_kernel.h
index 823c55393..c45e19a8f 100644
--- a/libcuda/ethash_cuda_miner_kernel.h
+++ b/libcuda/ethash_cuda_miner_kernel.h
@@ -20,7 +20,7 @@
 // one solution per stream hash calculation
 // Leave room for up to 4 results. A power
 // of 2 here will yield better CUDA optimization
-#define MAX_SEARCH_RESULTS 4U
+#define MAX_SEARCH_RESULTS 3U
 struct Search_results {
     uint32_t solCount;
     uint32_t hashCount;
@@ -47,8 +47,10 @@ typedef union {
     uint4 uint4s[64 / sizeof(uint4)];
 } hash64_t;
 
-void set_constants(hash128_t* _dag, uint32_t _dag_size, hash64_t* _light, uint32_t _light_size);
-void get_constants(hash128_t** _dag, uint32_t* _dag_size, hash64_t** _light, uint32_t* _light_size);
+void set_constants(hash128_t* _dag, uint32_t _dag_size, hash64_t* _light, uint32_t _light_size, uint32_t dag_inv,
+                   uint32_t dag_shift);
+void get_constants(hash128_t** _dag, uint32_t* _dag_size, hash64_t** _light, uint32_t* _light_size, uint32_t* dag_inv,
+                   uint32_t* dag_shift);
 void set_header(hash32_t _header);
 void set_target(uint64_t _target);
 void run_ethash_search(uint32_t gridSize, uint32_t blockSize, cudaStream_t stream, Search_results* g_output,
diff --git a/libcuda/ethash_cuda_miner_kernel_globals.h b/libcuda/ethash_cuda_miner_kernel_globals.h
index ceb4b7056..b8fd69ea4 100644
--- a/libcuda/ethash_cuda_miner_kernel_globals.h
+++ b/libcuda/ethash_cuda_miner_kernel_globals.h
@@ -10,6 +10,8 @@
 #pragma once
 
 __constant__ uint32_t d_dag_size;
+__constant__ uint32_t d_dag_inv;
+__constant__ uint32_t d_dag_shift;
 __constant__ hash128_t* d_dag;
 __constant__ uint32_t d_light_size;
 __constant__ hash64_t* d_light;
diff --git a/libeth/EthashAux.h b/libeth/EthashAux.h
index a071d0f4f..df80e7cab 100644
--- a/libeth/EthashAux.h
+++ b/libeth/EthashAux.h
@@ -33,6 +33,8 @@ struct EpochContext {
     size_t lightSize;
     ethash_hash512* lightCache = nullptr;
     int dagNumItems;
+    uint32_t dagInv;
+    uint32_t dagShift;
     uint64_t dagSize;
 };
 
diff --git a/libeth/Miner.cpp b/libeth/Miner.cpp
index b00b5fe2b..580ea1e70 100644
--- a/libeth/Miner.cpp
+++ b/libeth/Miner.cpp
@@ -149,6 +149,10 @@ void Miner::setEpoch(WorkPackage const& w) {
     m_epochContext.lightSize = ethash::get_light_cache_size(ec.light_cache_num_items);
     m_epochContext.dagNumItems = ec.full_dataset_num_items;
     m_epochContext.dagSize = ethash::get_full_dataset_size(ec.full_dataset_num_items);
+    m_epochContext.dagShift = 0;
+    while ((m_epochContext.dagInv = (0x100000000 << m_epochContext.dagShift) / m_epochContext.dagNumItems + 1) <
+           0x80000000)
+        m_epochContext.dagShift++;
     m_epochContext.lightCache = new ethash_hash512[m_epochContext.lightNumItems];
     memcpy(m_epochContext.lightCache, ec.light_cache, m_epochContext.lightSize);
 }
